'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var ReactDOM = require('react-dom');
var PropTypes = require('prop-types');
var button = require('@devseed-ui/button');
var collecticons = require('@devseed-ui/collecticons');
var typography = require('@devseed-ui/typography');
var styled = require('styled-components');
var themeProvider = require('@devseed-ui/theme-provider');
var toolbar = require('@devseed-ui/toolbar');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

var config = {
  disabled: false
};

var TransitionGroupContext = React__default["default"].createContext(null);

var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default["default"].findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : ReactDOM__default["default"].findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default["default"].findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      React__default["default"].createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : React__default["default"].cloneElement(React__default["default"].Children.only(children), childProps))
    );
  };

  return Transition;
}(React__default["default"].Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes = {}; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;

var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass$1(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props;
        _this$props.classNames;
        var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

    return /*#__PURE__*/React__default["default"].createElement(Transition$1, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(React__default["default"].Component);

CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition.propTypes = {};
var CSSTransition$1 = CSSTransition;

var _templateObject, _templateObject2;
var sizeMapping = {
  small: '32rem',
  medium: '48rem',
  large: '64rem',
  xlarge: '80rem',
  fullscreen: '100%'
};

var renderModalSize = function renderModalSize() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size;
  return styled.css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    max-width: ", ";\n  "])), sizeMapping[size]);
};

var ModalContents = /*#__PURE__*/styled__default["default"].div.withConfig({
  displayName: "styled__ModalContents",
  componentId: "sc-1f8l41k-0"
})(["display:grid;grid-template-columns:100%;grid-template-rows:", ";background:", ";border-radius:", ";width:100%;margin:", ";box-shadow:", ";", " > *:last-child{margin-bottom:0;}"], function (_ref) {
  var size = _ref.size;
  return size === 'fullscreen' ? "3rem auto" : "auto";
}, themeProvider.themeVal('color.surface'), themeProvider.themeVal('shape.rounded'), function (_ref2) {
  var size = _ref2.size;
  return size === 'fullscreen' ? 0 : "auto";
}, themeProvider.themeVal('boxShadow.elevationD'), renderModalSize);
var ModalWrapper = /*#__PURE__*/styled__default["default"].section.withConfig({
  displayName: "styled__ModalWrapper",
  componentId: "sc-1f8l41k-1"
})(["display:flex;position:fixed;top:0;bottom:0;left:0;right:0;z-index:9990;overflow-y:auto;opacity:1;visibility:visible;background:", ";transform:translate3d(0,0,0);padding:", ";&.modal-appear,&.modal-enter{opacity:0;visibility:hidden;}&.modal-enter-appear,&.modal-enter-active{transition:opacity 0.32s ease 0.1s,visibility 0.32s linear 0.1s;opacity:1;visibility:visible;}&.modal-exit{opacity:1;visibility:visible;}&.modal-exit-active{transition:opacity 0.32s ease 0.1s,visibility 0.32s linear 0.1s;opacity:0;visibility:hidden;}"], themeProvider.themeVal('color.base-400a'), function (_ref3) {
  var size = _ref3.size;
  return size === 'fullscreen' ? 0 : themeProvider.glsp(2);
});
var BodyUnscrollable = styled.createGlobalStyle(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  ", "\n"])), function (_ref4) {
  var revealed = _ref4.revealed;
  return revealed && "\n    body {\n      overflow-y: hidden;\n    }\n  ";
});
var ModalHeader = /*#__PURE__*/styled__default["default"].header.withConfig({
  displayName: "styled__ModalHeader",
  componentId: "sc-1f8l41k-2"
})(["display:flex;gap:", ";flex-flow:row nowrap;align-items:center;background:", ";padding:", ";border-radius:", " ", " 0 0;"], themeProvider.glsp(), themeProvider.themeVal('color.surface'), themeProvider.glsp(2), themeProvider.themeVal('shape.rounded'), themeProvider.themeVal('shape.rounded'));
var ModalHeadline = /*#__PURE__*/styled__default["default"].div.withConfig({
  displayName: "styled__ModalHeadline",
  componentId: "sc-1f8l41k-3"
})(["display:flex;flex-flow:column nowrap;"]);
var ModalToolbar = /*#__PURE__*/styled__default["default"](toolbar.Toolbar).withConfig({
  displayName: "styled__ModalToolbar",
  componentId: "sc-1f8l41k-4"
})(["margin-left:auto;padding:", ";"], themeProvider.glsp(1 / 8, 0, 1 / 8, 0));
var ModalBody = /*#__PURE__*/styled__default["default"].div.withConfig({
  displayName: "styled__ModalBody",
  componentId: "sc-1f8l41k-5"
})(["padding:0 ", ";&:first-child{padding-top:", ";}&:last-child{padding-bottom:", ";}"], themeProvider.glsp(2), themeProvider.glsp(2), themeProvider.glsp(2));
var ModalFooter = /*#__PURE__*/styled__default["default"].footer.withConfig({
  displayName: "styled__ModalFooter",
  componentId: "sc-1f8l41k-6"
})(["background:", ";padding:", ";border-radius:0 0 ", " ", ";"], themeProvider.themeVal('color.surface'), themeProvider.glsp(2), themeProvider.themeVal('shape.rounded'), themeProvider.themeVal('shape.rounded'));

var _excluded$1 = ["fn", "children"];
/**
 * Tries to render the given function falling back to the children if it is not
 * set.
 *
 * @param {function} fn The render function to try to run
 * @param {node} children The fallback if the render function is not set
 * @prop {any} rest Remaining props are passed to the function
 */

function Try(props) {
  /* eslint-disable-next-line react/prop-types */
  var F = props.fn,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded$1);

  if ( /*#__PURE__*/React__default["default"].isValidElement(F)) {
    return /*#__PURE__*/React__default["default"].createElement(F, props);
  } else if (typeof F === 'function') {
    return F(rest);
  } else {
    return children || null;
  }
}

var _excluded = ["id", "title", "content", "footerContent", "closeButton", "size", "revealed", "className", "disableKeyboardClose", "onCloseClick", "onOverlayClick", "renderContents", "renderHeader", "renderHeadline", "renderToolbar", "renderBody", "renderFooter"];
/**
 * React modal component.
 * Displays a modal component which is portaled to the body to ensure is appears
 * over all other elements
 *
 * @param {string} id An id for the modal
 * @param {bool} revealed Whether or not the modal is visible.
 * @param {string} size Size of the modal. One of "small", "medium", "large", "xlarge", "full"
 * @param {string} className Classes for the modal wrapper
 * @param {function} onOverlayClick Callback function for overlay click
 * @param {function} onCloseClick Callback function for close button click
 * @param {bool} closeButton Whether or not the modal should render
 *               the default close button. Default `true`.
 * @param {string} title Title for the modal. Required unless the header is
 *                 being overridden.
 * @param {node} content Modal body content, rendered inside `ModalBody`.
 *               Required unless the body is being overridden.
 * @param {bool} disableKeyboardClose Disables the use of keyboard to close the modal.
 * @param {node} footerContent Modal footer content, rendered
 *               inside `ModalFooter`.
 * @param {function} renderContents Overrides the contents of the modal.
 *                   Anything returned by this function is rendered inside
 *                   `ModalContents`.
 *                   Signature: fn(bag). Bag has the following props:
 *                     {function} close Method to close the modal.
 * @param {function} renderHeader Overrides the modal header element.
 *                   Anything returned by this function is rendered instead of
 *                   `ModalHeader`.
 *                   Signature: fn(bag). Bag has the following props:
 *                     {function} close Method to close the modal.
 * @param {function} renderHeadline Overrides the modal headline element.
 *                   Anything returned by this function is rendered instead of
 *                   `ModalHeadline`.
 *                   Signature: fn(bag). Bag has the following props:
 *                     {function} close Method to close the modal.
 * @param {function} renderToolbar Overrides the modal toolbar element.
 *                   Anything returned by this function is rendered instead of
 *                   `ModalToolbar`.
 *                   Signature: fn(bag). Bag has the following props:
 *                     {function} close Method to close the modal.
 * @param {function} renderBody Overrides the modal body element.
 *                   Anything returned by this function is rendered instead of
 *                   `ModalBody`.
 *                   Signature: fn(bag). Bag has the following props:
 *                     {function} close Method to close the modal.
 * @param {function} renderFooter Overrides the modal footer element.
 *                   Anything returned by this function is rendered instead of
 *                   `ModalFooter`.
 *                   Signature: fn(bag). Bag has the following props:
 *                     {function} close Method to close the modal.
 */

function Modal(props) {
  var id = props.id,
      title = props.title,
      content = props.content,
      footerContent = props.footerContent,
      closeButton = props.closeButton,
      size = props.size,
      revealed = props.revealed,
      className = props.className,
      disableKeyboardClose = props.disableKeyboardClose,
      onCloseClick = props.onCloseClick,
      onOverlayClick = props.onOverlayClick,
      renderContents = props.renderContents,
      renderHeader = props.renderHeader,
      renderHeadline = props.renderHeadline,
      renderToolbar = props.renderToolbar,
      renderBody = props.renderBody,
      renderFooter = props.renderFooter,
      rest = _objectWithoutProperties(props, _excluded);

  var uuid = React.useRef(Modal.generateUUID());

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasMounted = _useState2[0],
      setHasMounted = _useState2[1];

  var _useState3 = React.useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      modalElement = _useState4[0],
      setModalElement = _useState4[1]; // Key listener for esc key.


  React.useEffect(function () {
    if (disableKeyboardClose) return;

    var keyListener = function keyListener(e) {
      // ESC.
      if (revealed && e.keyCode === 27) {
        e.preventDefault();
        onCloseClick(e);
      }
    };

    document.addEventListener('keyup', keyListener);
    return function () {
      document.removeEventListener('keyup', keyListener);
    };
  }, [revealed, onCloseClick, disableKeyboardClose]); // Will be called on initial mount.

  React.useEffect(function () {
    var el = document.createElement('div');
    el.className = "modal-portal-".concat(uuid.current);
    document.body.appendChild(el);
    setModalElement(el);
    setHasMounted(true);
    return function () {
      document.body.removeChild(el);
    };
  }, []); // Note:
  // This check is necessary for this component to work when used with SSR.
  // While react-portal will itself check if window is available, that is not
  // enough to ensure that there aren't discrepancies between what the server
  // renders and what the client renders, as the client *will* have access to
  // the window. Therefore, we should only render the root level portal element
  // once the component has actually mounted, as determined by a state variable.

  if (!hasMounted) {
    return null;
  }

  var _onOverlayClick = function _onOverlayClick(e) {
    // Prevent children from triggering this.
    if (e.target === e.currentTarget && typeof onOverlayClick === 'function') {
      onOverlayClick(e);
    }
  };

  var klasses = ['modal', className];

  var _onCloseClick = function _onCloseClick(e) {
    e.preventDefault();
    onCloseClick(e);
  };

  var fnBag = {
    close: _onCloseClick
  };
  return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default["default"].createElement(CSSTransition$1, {
    in: revealed,
    appear: true,
    unmountOnExit: true,
    classNames: "modal",
    timeout: {
      enter: 400,
      exit: 400
    }
  }, /*#__PURE__*/React__default["default"].createElement(ModalWrapper, _extends$1({
    className: klasses.join(' '),
    key: "modal-".concat(id),
    onClick: _onOverlayClick,
    id: id,
    size: size
  }, rest), /*#__PURE__*/React__default["default"].createElement(BodyUnscrollable, {
    revealed: revealed
  }), /*#__PURE__*/React__default["default"].createElement(ModalContents, {
    className: "modal__contents",
    size: size
  }, /*#__PURE__*/React__default["default"].createElement(Try, _extends$1({
    fn: renderContents
  }, fnBag), /*#__PURE__*/React__default["default"].createElement(Try, _extends$1({
    fn: renderHeader
  }, fnBag), /*#__PURE__*/React__default["default"].createElement(ModalHeader, null, /*#__PURE__*/React__default["default"].createElement(Try, _extends$1({
    fn: renderHeadline
  }, fnBag), /*#__PURE__*/React__default["default"].createElement(ModalHeadline, null, /*#__PURE__*/React__default["default"].createElement(typography.Heading, {
    size: "small"
  }, title))), /*#__PURE__*/React__default["default"].createElement(Try, _extends$1({
    fn: renderToolbar
  }, fnBag), closeButton && /*#__PURE__*/React__default["default"].createElement(ModalToolbar, null, /*#__PURE__*/React__default["default"].createElement(button.Button, {
    size: "small",
    fitting: "skinny",
    onClick: _onCloseClick,
    title: "Close modal"
  }, /*#__PURE__*/React__default["default"].createElement(collecticons.CollecticonXmarkSmall, {
    title: "Close modal",
    meaningful: true
  })))))), /*#__PURE__*/React__default["default"].createElement(Try, _extends$1({
    fn: renderBody
  }, fnBag), /*#__PURE__*/React__default["default"].createElement(ModalBody, null, content)), /*#__PURE__*/React__default["default"].createElement(Try, _extends$1({
    fn: renderFooter
  }, fnBag), footerContent ? /*#__PURE__*/React__default["default"].createElement(ModalFooter, null, footerContent) : null))))), modalElement);
} // Use a static method to generate a uuid so it can be mocked during tests.


Modal.generateUUID = function () {
  return Math.random().toString(36).substr(2, 5);
};

Modal.defaultProps = {
  closeButton: true,
  revealed: false,
  size: 'medium',
  onOverlayClick: function onOverlayClick() {
  },
  onCloseClick: function onCloseClick() {
  }
};
Modal.propTypes = {
  id: PropTypes.PropTypes.string.isRequired,
  revealed: PropTypes.PropTypes.bool,
  className: PropTypes.PropTypes.string,
  size: PropTypes.PropTypes.oneOf(['small', 'medium', 'large', 'xlarge', 'fullscreen']),
  onOverlayClick: PropTypes.PropTypes.func,
  onCloseClick: PropTypes.PropTypes.func,
  closeButton: PropTypes.PropTypes.bool,
  disableKeyboardClose: PropTypes.PropTypes.bool,
  title: PropTypes.PropTypes.string,
  renderContents: PropTypes.PropTypes.func,
  renderHeader: PropTypes.PropTypes.func,
  renderHeadline: PropTypes.PropTypes.func,
  renderToolbar: PropTypes.PropTypes.func,
  renderBody: PropTypes.PropTypes.func,
  content: PropTypes.PropTypes.node,
  renderFooter: PropTypes.PropTypes.func,
  footerContent: PropTypes.PropTypes.node
};

exports.Modal = Modal;
exports.ModalBody = ModalBody;
exports.ModalFooter = ModalFooter;
exports.ModalHeader = ModalHeader;
exports.ModalHeadline = ModalHeadline;
exports.ModalToolbar = ModalToolbar;
//# sourceMappingURL=index.cjs.js.map
