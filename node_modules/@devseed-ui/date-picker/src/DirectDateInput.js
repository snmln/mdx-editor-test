import React, { useState } from 'react';
import T from 'prop-types';
import { endOfDay } from 'date-fns';
import { Form, FormHelperMessage } from '@devseed-ui/form';

import StressedFormGroupInput from './StressedFormGroupInput';
import {
  compareDates,
  formatDate,
  parseDateStr,
  useDateNotAllowed
} from './utils';

export default function DirectDateInput(props) {
  const {
    id,
    isRange,
    value: { start, end },
    onChange,
    view,
    min,
    max,
    datesToRestrict,
    restrictMode
  } = props;

  const [errors, setErrors] = useState({});

  const isDateDisallowed = useDateNotAllowed(datesToRestrict, restrictMode, {
    view
  });

  // The change handler for StressedField returns a setter for the internal
  // draft value. The use case for this is quite peculiar.
  // It is used to ensure that the date is rerendered on the input field when
  // the view it other than month.
  // For example, with the year view, for the date 2020/01/01 the value in the
  // input would be Jan 2020.
  // If we input the date 2020/01/10, the resulting date will remain the same
  // since we're only looking at the month and year. This result in the
  // component not being rerendered and the value in the input would remain
  // 2020/01/10. This sets a state value to force a rerender.
  // Another, maybe better, option would be to store dates as they are input and
  // only format them once the datepicker is confirmed. This could be considered
  // in a future revision.
  const onValChangeSingle = (v, setV) => {
    const date = parseDateStr(v, { view });
    !!date && setV(formatDate(date, { view }));
    onChange({ start: date, end: date });
  };

  const onValChangeStart = (v, setV) => {
    const date = parseDateStr(v, { view });
    !!date && setV(formatDate(date, { view }));
    onChange({ start: date, end });
  };

  const onValChangeEnd = (v, setV) => {
    const date = parseDateStr(v, { view });
    !!date && setV(formatDate(date, { view }));
    // If there's a date set we want to set it to the end of day.
    onChange({ start, end: date && endOfDay(date) });
  };

  const onValidate = (field, v) => {
    const date = parseDateStr(v, { view });
    // Clean the errors.
    /* eslint-disable-next-line no-unused-vars */
    setErrors(({ [field]: _, ...rest }) => rest);

    if (!date) return false;

    if (isDateDisallowed({ date, view })) {
      setErrors((e) => ({ ...e, [field]: 'disallowed' }));
      return false;
    }

    if (min && compareDates(date, min, { view }) === -1) {
      setErrors((e) => ({ ...e, [field]: 'min-date' }));
      return false;
    }

    if (max && compareDates(date, max, { view }) === 1) {
      setErrors((e) => ({ ...e, [field]: 'max-date' }));
      return false;
    }

    if (isRange) {
      // If the start date is being set and there's an end, ensure it is before
      // that date.
      if (
        field === 'dateStart' &&
        end &&
        compareDates(date, end, { view }) === 1
      ) {
        setErrors((e) => ({ ...e, [field]: 'after-end' }));
        return false;
      }

      // If the end date is being set and there's a start, ensure it is after
      // that date.
      if (
        field === 'dateEnd' &&
        start &&
        compareDates(date, start, { view }) === -1
      ) {
        setErrors((e) => ({ ...e, [field]: 'before-start' }));
        return false;
      }
    }

    return true;
  };

  const renderError = (field) => {
    if (!errors[field]) return null;

    return (
      <FormHelperMessage invalid>
        {errors[field] === 'min-date' &&
          `Date must be after or on: ${formatDate(min, { view })}`}
        {errors[field] === 'max-date' &&
          `Date must be before or on: ${formatDate(max, { view })}`}
        {errors[field] === 'after-end' &&
          `Date must be before end date: ${formatDate(end, { view })}`}
        {errors[field] === 'before-start' &&
          `Date must be after start date: ${formatDate(start, { view })}`}
        {errors[field] === 'disallowed' && `The inserted date is not allowed`}
      </FormHelperMessage>
    );
  };

  const placeholderDate = new Date();

  return isRange ? (
    <Form>
      {/* Prevent implicit submission of the form */}
      <button
        type='submit'
        disabled
        style={{ display: 'none' }}
        aria-hidden='true'
      />
      <StressedFormGroupInput
        inputType='text'
        id={`${id}-date-start`}
        name={`${id}-date-start`}
        label='Start date'
        value={formatDate(start, { view })}
        validate={onValidate.bind(null, 'dateStart')}
        onChange={onValChangeStart}
        placeholder={formatDate(placeholderDate, { view })}
        helper={renderError('dateStart')}
      />
      <StressedFormGroupInput
        inputType='text'
        id={`${id}-date-end`}
        name={`${id}-date-end`}
        label='End date'
        value={formatDate(end, { view })}
        validate={onValidate.bind(null, 'dateEnd')}
        onChange={onValChangeEnd}
        placeholder={formatDate(placeholderDate, { view })}
        helper={renderError('dateEnd')}
      />
    </Form>
  ) : (
    <Form>
      {/* Prevent implicit submission of the form */}
      <button
        type='submit'
        disabled
        style={{ display: 'none' }}
        aria-hidden='true'
      />
      <StressedFormGroupInput
        inputType='text'
        id={`${id}-date`}
        name={`${id}-date`}
        label='Date'
        value={formatDate(start, { view })}
        validate={onValidate.bind(null, 'date')}
        onChange={onValChangeSingle}
        placeholder={formatDate(placeholderDate, { view })}
        helper={renderError('date')}
      />
    </Form>
  );
}

DirectDateInput.propTypes = {
  id: T.string,
  isRange: T.bool,
  value: T.shape({
    start: T.instanceOf(Date),
    end: T.instanceOf(Date)
  }),
  min: T.instanceOf(Date),
  max: T.instanceOf(Date),
  view: T.string,
  onChange: T.func,
  datesToRestrict: T.arrayOf(T.instanceOf(Date)),
  restrictMode: T.oneOf(['enable', 'disable'])
};

DirectDateInput.defaultProps = {
  restrictMode: 'disable'
};
