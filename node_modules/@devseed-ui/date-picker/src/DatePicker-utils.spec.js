import { eachDayOfInterval, format } from 'date-fns';
import { cleanup } from '@testing-library/react';
import { renderHook } from '@testing-library/react-hooks';
import { Dropdown } from '@devseed-ui/dropdown';

import {
  compareDates,
  parseDateStr,
  formatRangeLabel,
  prepareInputDates,
  computeDisabledDates,
  useDateNotAllowed
} from './utils';

const originalFn = Dropdown.generateUUID;
Dropdown.generateUUID = () => 'test-uuid';

afterAll(() => {
  cleanup();
  Dropdown.generateUUID = originalFn;
});

afterEach(() => {
  cleanup();
});

describe('<DatePicker />', () => {
  describe('utils', () => {
    describe('parseDateStr', () => {
      const baseDateExpect = '2020/01/01';
      const baseFullDates = [
        ['2020/01/01', baseDateExpect],
        ['2020-01-01', baseDateExpect],
        ['2020.01.01', baseDateExpect],
        ['2020 01 01', baseDateExpect],
        ['2020 january 01', baseDateExpect],
        ['2020 jan 01', baseDateExpect],
        ['01 january 2020', baseDateExpect],
        ['01 jan 2020', baseDateExpect],
        ['january 01 2020', baseDateExpect],
        ['jan 01 2020', baseDateExpect],
        ['january 1st 2020', baseDateExpect],
        ['jan 01st 2020', baseDateExpect]
      ];
      const baseMonthDates = [
        ['2020/01', baseDateExpect],
        ['2020-01', baseDateExpect],
        ['2020.01', baseDateExpect],
        ['2020 01', baseDateExpect],
        ['2020 january', baseDateExpect],
        ['2020 jan', baseDateExpect],
        ['january 2020', baseDateExpect],
        ['jan 2020', baseDateExpect],
        ['january 2020', baseDateExpect],
        ['jan 2020', baseDateExpect],
        ['january 2020', baseDateExpect],
        ['jan 2020', baseDateExpect],
        // day should be ignored.
        ['13 jan 2020', baseDateExpect]
      ];

      const fullDates = [
        ...baseFullDates,
        ['jan 02nd 2020', '2020/01/02'],
        ['jan 03rd 2020', '2020/01/03'],
        ['jan 04th 2020', '2020/01/04'],
        ['May 01st 2020', '2020/05/01']
      ];

      const monthDates = [
        ...baseFullDates,
        ...baseMonthDates,
        // day should be ignored.
        ['Feb 02nd 2020', '2020/02/01'],
        ['Mar 03rd 2020', '2020/03/01'],
        ['May 04th 2020', '2020/05/01']
      ];

      const yearDates = [
        ...baseFullDates,
        ...baseMonthDates,
        ['2020', baseDateExpect],
        // month and day should be ignored.
        ['2020 march 01', baseDateExpect]
      ];

      describe('month view', () => {
        it.each(fullDates)(`should parse: %s`, (input, expected) => {
          const date = parseDateStr(input, { view: 'month' });
          const dStr = date && format(date, 'yyyy/MM/dd');
          expect(dStr).toEqual(expected);
        });
      });

      describe('year view', () => {
        it.each(monthDates)(`should parse: %s`, (input, expected) => {
          const date = parseDateStr(input, { view: 'year' });
          const dStr = date && format(date, 'yyyy/MM/dd');
          expect(dStr).toEqual(expected);
        });
      });

      describe('decade view', () => {
        it.each(yearDates)(`should parse: %s`, (input, expected) => {
          const date = parseDateStr(input, { view: 'decade' });
          const dStr = date && format(date, 'yyyy/MM/dd');
          expect(dStr).toEqual(expected);
        });
      });

      it('should return null when parsing invalid dates', () => {
        expect(parseDateStr('not a date', { view: 'month' })).toBe(null);
        expect(parseDateStr('not a date', { view: 'year' })).toBe(null);
        expect(parseDateStr('not a date', { view: 'decade' })).toBe(null);
        expect(parseDateStr('20/21/2020', { view: 'month' })).toBe(null);
        expect(parseDateStr('january 12or2020', { view: 'month' })).toBe(null);
      });
    });

    describe('compareDates', () => {
      const datesLess = [
        [new Date('2020/01/01'), new Date('2020/01/02'), 'month', -1],
        [new Date('2020/01/01'), new Date('2020/02/01'), 'month', -1],
        [new Date('2020/01/01'), new Date('2021/01/01'), 'month', -1],
        [new Date('2020/01/01'), new Date('2020/02/01'), 'year', -1],
        [new Date('2020/01/01'), new Date('2021/01/01'), 'year', -1],
        [new Date('2020/01/01'), new Date('2021/01/01'), 'decade', -1]
      ];
      const datesSame = [
        [new Date('2020/01/01'), new Date('2020/01/01'), 'month', 0],
        [new Date('2020/01/01'), new Date('2020/01/01'), 'year', 0],
        [new Date('2020/01/01'), new Date('2020/01/02'), 'year', 0],
        [new Date('2020/01/02'), new Date('2020/01/01'), 'year', 0],
        [new Date('2020/01/01'), new Date('2020/01/01'), 'decade', 0],
        [new Date('2020/01/01'), new Date('2020/01/02'), 'decade', 0],
        [new Date('2020/01/02'), new Date('2020/01/01'), 'decade', 0],
        [new Date('2020/01/01'), new Date('2020/02/01'), 'decade', 0],
        [new Date('2020/01/01'), new Date('2020/02/02'), 'decade', 0],
        [new Date('2020/01/02'), new Date('2020/03/01'), 'decade', 0]
      ];
      const datesMore = [
        [new Date('2020/01/02'), new Date('2020/01/01'), 'month', 1],
        [new Date('2020/02/01'), new Date('2020/01/01'), 'month', 1],
        [new Date('2021/01/01'), new Date('2020/01/01'), 'month', 1],
        [new Date('2020/02/01'), new Date('2020/01/01'), 'year', 1],
        [new Date('2021/01/01'), new Date('2020/01/01'), 'year', 1],
        [new Date('2021/01/01'), new Date('2020/01/01'), 'decade', 1]
      ];

      it.each(datesLess)(
        `date %s should be greater than %s for view %s`,
        (a, b, view, expected) => {
          const result = compareDates(a, b, { view });
          expect(result).toEqual(expected);
        }
      );

      it.each(datesSame)(
        `date %s should be the same as %s for view %s`,
        (a, b, view, expected) => {
          const result = compareDates(a, b, { view });
          expect(result).toEqual(expected);
        }
      );

      it.each(datesMore)(
        `date %s should be less than %s for view %s`,
        (a, b, view, expected) => {
          const result = compareDates(a, b, { view });
          expect(result).toEqual(expected);
        }
      );
    });

    describe('formatRangeLabel', () => {
      const ranges = [
        [null, null, 'month', 'From start — end'],
        [new Date('2020/01/01'), null, 'month', 'Jan 1st, 2020 — end'],
        [null, new Date('2020/01/01'), 'month', 'From start — Jan 1st, 2020'],
        [null, null, 'year', 'From start — end'],
        [new Date('2020/01/01'), null, 'year', 'Jan 2020 — end'],
        [null, new Date('2020/01/01'), 'year', 'From start — Jan 2020'],
        [null, null, 'decade', 'From start — end'],
        [new Date('2020/01/01'), null, 'decade', '2020 — end'],
        [null, new Date('2020/01/01'), 'decade', 'From start — 2020'],
        // start, end, view, expected
        [
          new Date('2020/01/01'),
          new Date('2020/01/01'),
          'month',
          'Jan 1st, 2020'
        ],
        [
          new Date('2020/01/01'),
          new Date('2020/01/10'),
          'month',
          'Jan 01-10, 2020'
        ],
        [
          new Date('2020/01/01'),
          new Date('2020/12/10'),
          'month',
          'Jan 1st — Dec 10th, 2020'
        ],
        [
          new Date('2020/01/01'),
          new Date('2021/12/10'),
          'month',
          'Jan 1st, 2020 — Dec 10th, 2021'
        ],
        [new Date('2020/01/01'), new Date('2020/01/01'), 'year', 'Jan 2020'],
        [new Date('2020/01/01'), new Date('2020/01/10'), 'year', 'Jan 2020'],
        [
          new Date('2020/01/01'),
          new Date('2020/12/10'),
          'year',
          'Jan — Dec 2020'
        ],
        [
          new Date('2020/01/01'),
          new Date('2021/12/10'),
          'year',
          'Jan 2020 — Dec 2021'
        ],
        [new Date('2020/01/01'), new Date('2020/01/01'), 'decade', '2020'],
        [new Date('2020/01/01'), new Date('2020/01/10'), 'decade', '2020'],
        [new Date('2020/01/01'), new Date('2020/12/10'), 'decade', '2020'],
        [
          new Date('2020/01/01'),
          new Date('2021/12/10'),
          'decade',
          '2020 — 2021'
        ]
      ];

      it.each(ranges)(
        `range label %s - %s for view %s should be correctly formatted`,
        (start, end, view, expected) => {
          const result = formatRangeLabel(
            {
              start,
              end
            },
            { view }
          );
          expect(result).toEqual(expected);
        }
      );
    });

    describe('prepareInputDates', () => {
      const dateA = new Date('2020/01/01');
      const dateB = new Date('2021/02/03');

      it('should prepare range from invalid dates for non range', () => {
        const res = prepareInputDates('nothi', { isRange: false });
        expect(res).toEqual({
          start: null,
          end: null
        });
      });

      it('should prepare range from null dates for non range', () => {
        const res = prepareInputDates(null, { isRange: false });
        expect(res).toEqual({
          start: null,
          end: null
        });
      });

      it('should prepare range from valid date for non range', () => {
        const res = prepareInputDates(dateA, { isRange: false });
        expect(res).toEqual({
          start: dateA,
          end: dateA
        });
      });

      it('should prepare range from valid range date for non range', () => {
        const res = prepareInputDates({ start: dateA }, { isRange: false });
        expect(res).toEqual({
          start: dateA,
          end: dateA
        });
      });

      it('should prepare range from invalid date for range', () => {
        const res = prepareInputDates('nothi', {
          isRange: true,
          view: 'month'
        });
        expect(res).toEqual({
          start: null,
          end: null
        });
      });

      it('should prepare range from invalid date range for range', () => {
        const res = prepareInputDates(
          { start: 'invalid', end: 'invalid' },
          { isRange: true, view: 'month' }
        );
        expect(res).toEqual({
          start: null,
          end: null
        });
      });

      it('should prepare range from invalid date range (end) for range', () => {
        const res = prepareInputDates(
          { start: dateA, end: 'invalid' },
          { isRange: true, view: 'month' }
        );
        expect(res).toEqual({
          start: dateA,
          end: null
        });
      });

      it('should prepare range from invalid date range (start) for range', () => {
        const res = prepareInputDates(
          { start: 'invalid', end: dateB },
          { isRange: true, view: 'month' }
        );
        expect(res).toEqual({
          start: null,
          end: dateB
        });
      });

      it('should prepare range from valid date for range', () => {
        const res = prepareInputDates(
          { start: dateA, end: dateB },
          { isRange: true, view: 'month' }
        );
        expect(res).toEqual({
          start: dateA,
          end: dateB
        });
      });

      it('should prepare range from valid inverted range date for range', () => {
        const res = prepareInputDates(
          { start: dateB, end: dateA },
          { isRange: true, view: 'month' }
        );
        expect(res).toEqual({
          start: dateA,
          end: dateB
        });
      });
    });

    describe('computeDisabledDates', () => {
      const dates = [
        new Date('2022/05/20'),
        new Date('2022/05/22'),
        new Date('2022/05/25'),
        new Date('2026/01/01'),
        new Date('2022/06/01'),
        // The full month of june 2022
        ...eachDayOfInterval({
          start: new Date('2022/06/01'),
          end: new Date('2022/06/30')
        }),
        // The full year 2023
        ...eachDayOfInterval({
          start: new Date('2023/01/01'),
          end: new Date('2023/12/31')
        })
      ];

      it('should compute disabled dates for view: month', () => {
        const result = computeDisabledDates(dates, { view: 'month' });

        expect(result).toEqual({
          years: [new Date('2023/01/01')],
          months: [
            new Date('2022/06/01'),
            new Date('2023/01/01'),
            new Date('2023/02/01'),
            new Date('2023/03/01'),
            new Date('2023/04/01'),
            new Date('2023/05/01'),
            new Date('2023/06/01'),
            new Date('2023/07/01'),
            new Date('2023/08/01'),
            new Date('2023/09/01'),
            new Date('2023/10/01'),
            new Date('2023/11/01'),
            new Date('2023/12/01')
          ],
          // The days are always all the dates
          days: dates
        });
      });

      it('should compute disabled dates for view: year', () => {
        const result = computeDisabledDates(dates, { view: 'year' });

        expect(result).toEqual({
          years: [new Date('2023/01/01')],
          months: [
            new Date('2022/05/01'),
            new Date('2026/01/01'),
            new Date('2022/06/01'),
            new Date('2023/01/01'),
            new Date('2023/02/01'),
            new Date('2023/03/01'),
            new Date('2023/04/01'),
            new Date('2023/05/01'),
            new Date('2023/06/01'),
            new Date('2023/07/01'),
            new Date('2023/08/01'),
            new Date('2023/09/01'),
            new Date('2023/10/01'),
            new Date('2023/11/01'),
            new Date('2023/12/01')
          ],
          days: []
        });
      });

      it('should compute disabled dates for view: decade', () => {
        const result = computeDisabledDates(dates, { view: 'decade' });

        expect(result).toEqual({
          years: [
            new Date('2022/01/01'),
            new Date('2023/01/01'),
            new Date('2026/01/01')
          ],
          months: [],
          days: []
        });
      });
    });

    describe('useDateNotAllowed hook', () => {
      const dates = [
        new Date('2022/05/20'),
        new Date('2022/05/22'),
        new Date('2022/05/25'),
        new Date('2026/01/01'),
        new Date('2022/06/01'),
        // The full month of june 2022
        ...eachDayOfInterval({
          start: new Date('2022/06/01'),
          end: new Date('2022/06/30')
        }),
        // The full year 2023
        ...eachDayOfInterval({
          start: new Date('2023/01/01'),
          end: new Date('2023/12/31')
        })
      ];

      it('should check if date is disallowed according with behavior and view', () => {
        // Helper to create the parameter for isDateDisallowed function.
        const d = (dateStr, view) => ({ date: new Date(dateStr), view });

        const { result, rerender } = renderHook(
          ({ behavior, maxView }) => {
            return useDateNotAllowed(dates, behavior, { view: maxView });
          },
          { initialProps: { behavior: 'disable', maxView: 'month' } }
        );

        let isDateDisallowed = result.current;

        expect(isDateDisallowed(d('2022/05/20', 'month'))).toBeTruthy();
        expect(isDateDisallowed(d('2022/06/15', 'month'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/06/15', 'month'))).toBeTruthy();
        expect(isDateDisallowed(d('2020/06/15', 'month'))).toBeFalsy();

        expect(isDateDisallowed(d('2022/05/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2022/06/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/02/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/06/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/12/01', 'year'))).toBeTruthy();

        expect(isDateDisallowed(d('2022/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2026/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/01/01', 'decade'))).toBeTruthy();

        // When the maxView is year, there's no month calendar view.
        rerender({ behavior: 'disable', maxView: 'year' });
        isDateDisallowed = result.current;

        expect(isDateDisallowed(d('2022/01/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2022/05/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2022/06/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/02/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/06/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/12/01', 'year'))).toBeTruthy();

        expect(isDateDisallowed(d('2022/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2026/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/01/01', 'decade'))).toBeTruthy();

        // When the maxView is decade, there's no month or year calendar view.
        rerender({ behavior: 'disable', maxView: 'decade' });
        isDateDisallowed = result.current;

        expect(isDateDisallowed(d('2021/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2022/01/01', 'decade'))).toBeTruthy();
        expect(isDateDisallowed(d('2026/01/01', 'decade'))).toBeTruthy();
        expect(isDateDisallowed(d('2022/06/01', 'decade'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/02/01', 'decade'))).toBeTruthy();
        expect(isDateDisallowed(d('2023/01/01', 'decade'))).toBeTruthy();

        // Switch to enable
        // When the maxView is year, there's no month calendar view.
        rerender({ behavior: 'enable', maxView: 'month' });
        isDateDisallowed = result.current;

        expect(isDateDisallowed(d('2022/05/20', 'month'))).toBeFalsy();
        expect(isDateDisallowed(d('2022/06/15', 'month'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/06/15', 'month'))).toBeFalsy();
        expect(isDateDisallowed(d('2020/06/15', 'month'))).toBeTruthy();

        expect(isDateDisallowed(d('2022/05/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2022/06/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/02/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/06/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2020/12/01', 'year'))).toBeTruthy();

        expect(isDateDisallowed(d('2022/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2026/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2021/01/01', 'decade'))).toBeTruthy();

        // When the maxView is year, there's no month calendar view.
        rerender({ behavior: 'enable', maxView: 'year' });
        isDateDisallowed = result.current;

        expect(isDateDisallowed(d('2022/01/01', 'year'))).toBeTruthy();
        expect(isDateDisallowed(d('2022/05/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2026/01/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/02/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/06/01', 'year'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/12/01', 'year'))).toBeFalsy();

        expect(isDateDisallowed(d('2021/01/01', 'decade'))).toBeTruthy();
        expect(isDateDisallowed(d('2022/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2026/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/01/01', 'decade'))).toBeFalsy();

        // When the maxView is decade, there's no month or year calendar view.
        rerender({ behavior: 'enable', maxView: 'decade' });
        isDateDisallowed = result.current;

        expect(isDateDisallowed(d('2021/01/01', 'decade'))).toBeTruthy();
        expect(isDateDisallowed(d('2022/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2026/01/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2022/06/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/02/01', 'decade'))).toBeFalsy();
        expect(isDateDisallowed(d('2023/01/01', 'decade'))).toBeFalsy();
      });
    });
  });
});
