import React from 'react';
import { renderToString } from 'react-dom/server';
import sinon from 'sinon';
import { endOfDay, startOfDay } from 'date-fns';
import {
  cleanup,
  screen,
  waitFor,
  waitForElementToBeRemoved
} from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Dropdown } from '@devseed-ui/dropdown';
import { DevseedUiThemeProvider } from '@devseed-ui/theme-provider';

import { renderWithTheme } from '../../../test/_setup-theme-provider';

import { DatePicker } from '.';

const renderComp = (tree) => renderWithTheme(tree, null);

const originalFn = Dropdown.generateUUID;
Dropdown.generateUUID = () => 'test-uuid';

// The calendar buttons have the following structure:
// <button><abbr aria-label></abbr></button>
// Since using getByRole makes tests very slow, we query the abbr and the return
// the parent button.
const getCalendarButton = (label) => screen.getByLabelText(label).parentElement;

afterAll(() => {
  cleanup();
  Dropdown.generateUUID = originalFn;
});

afterEach(() => {
  cleanup();
});

describe('<DatePicker />', () => {
  describe('Component', () => {
    const openOnInput = () => {
      const trigger = screen.getByTitle(/Select date/);
      userEvent.click(trigger);

      // Change tab.
      const inputTabBtn = screen.getByTitle(/select input tab/i);
      userEvent.click(inputTabBtn);
    };

    describe('global testing', () => {
      it.each(['single', 'range'])(
        'renders default button for type: %s',
        (type) => {
          const result = renderComp(
            <DatePicker id='date-picker' isRange={type === 'range'} />
          );
          expect(result.container).toMatchSnapshot();
        }
      );

      it.each(['single', 'range'])(
        'renders custom trigger element for type: %s',
        (type) => {
          const result = renderComp(
            <DatePicker
              id='date-picker'
              isRange={type === 'range'}
              renderTriggerElement={({ active, ...props }, label) => (
                <span {...props} active={active.toString()}>
                  {label}
                </span>
              )}
            />
          );
          expect(result.container).toMatchSnapshot();
        }
      );

      it.each([
        ['month', 'single'],
        ['month', 'range'],
        ['year', 'single'],
        ['year', 'range'],
        ['decade', 'single'],
        ['decade', 'range']
      ])(
        'renders the calendar for view [%s] and type [%s] including additional content',
        (view, type) => {
          // Ensure we're opening it on a known date.
          const date = new Date('2020/01/01');
          const clock = sinon.useFakeTimers(date.getTime());

          const result = renderComp(
            <DatePicker
              id='date-picker'
              view={view}
              isRange={type === 'range'}
              renderAdditionalContent={(props) => (
                <p>{JSON.stringify(props)}</p>
              )}
            />
          );
          const trigger = result.getByTitle(/Select date/);
          userEvent.click(trigger);
          expect(result.baseElement).toMatchSnapshot();

          clock.restore();
        }
      );

      it.each([
        ['month', 'single'],
        ['month', 'range'],
        ['year', 'single'],
        ['year', 'range'],
        ['decade', 'single'],
        ['decade', 'range']
      ])(
        'renders the input for view [%s] and type [%s] including additional content',
        (view, type) => {
          // Ensure we're opening it on a known date.
          const date = new Date('2020/01/01');
          const clock = sinon.useFakeTimers(date.getTime());

          const result = renderComp(
            <DatePicker
              id='date-picker'
              view={view}
              isRange={type === 'range'}
              renderAdditionalContent={(props) => (
                <p>{JSON.stringify(props)}</p>
              )}
            />
          );
          openOnInput();

          expect(result.baseElement).toMatchSnapshot();

          clock.restore();
        }
      );

      it('opens the datepicker on main view', async () => {
        const result = renderComp(<DatePicker id='date-picker' />);
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);
        // Check that we are in the calendar view.
        expect(
          result.baseElement.querySelector('.react-calendar__navigation__label')
        ).toBeVisible();
        // Change tab.
        const inputTabBtn = screen.getByRole('link', {
          name: /select input tab/i
        });
        userEvent.click(inputTabBtn);
        // Check that we changed tab. Look for the form
        // textbox
        expect(
          screen.getByLabelText(/date/i, {
            selector: 'input'
          })
        ).toBeVisible();
        const datePickerEl = result.baseElement.querySelector('#date-picker');
        // Close date picker.
        userEvent.click(trigger);
        await waitForElementToBeRemoved(datePickerEl);
        // Reopen date picker.
        userEvent.click(trigger);
        // Check that we are in the calendar view again.
        expect(
          result.baseElement.querySelector('.react-calendar__navigation__label')
        ).toBeVisible();
      });

      it('should have attr to close drop on action buttons', () => {
        renderComp(<DatePicker id='date-picker' />);
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        expect(screen.getByLabelText(/save date selection/i)).toHaveAttribute(
          'data-dropdown',
          'click.close'
        );
        expect(screen.getByLabelText(/cancel date selection/i)).toHaveAttribute(
          'data-dropdown',
          'click.close'
        );
      });

      it('should render the clear button on every tab with isClearable set to true', () => {
        const result = renderComp(<DatePicker id='date-picker' isClearable />);
        const trigger = result.getByTitle(/Select date/);
        userEvent.click(trigger);

        expect(result.getByLabelText(/clear date selection/i)).toBeVisible();

        // Change tab.
        const inputTabBtn = result.getByTitle(/select input tab/i);
        userEvent.click(inputTabBtn);

        expect(result.getByLabelText(/clear date selection/i)).toBeVisible();
      });
    });

    describe('single date picker', () => {
      it('should render a draft date and commit on confirm', () => {
        // Ensure we're opening it on a known date.
        const date = new Date('2020/01/01');
        const clock = sinon.useFakeTimers(date.getTime());

        const onConfirmMock = jest.fn();

        renderComp(<DatePicker id='date-picker' onConfirm={onConfirmMock} />);
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // Check that the draft date on the picker is not set.
        expect(screen.getByTestId('devseedui-current-date')).toHaveTextContent(
          'Date'
        );

        // Select a date through the calendar.
        userEvent.click(getCalendarButton(/january 10, 2020/i));

        // Check that the draft date on the picker is set.
        expect(screen.getByTestId('devseedui-current-date')).toHaveTextContent(
          'Jan 10th, 2020'
        );

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/10')),
          end: startOfDay(new Date('2020/01/10'))
        });

        clock.restore();
      });

      it('should render a draft date and clear on clear click', () => {
        // Ensure we're opening it on a known date.
        const date = new Date('2020/01/01');
        const clock = sinon.useFakeTimers(date.getTime());

        const onConfirmMock = jest.fn();

        renderComp(
          <DatePicker
            id='date-picker'
            onConfirm={onConfirmMock}
            value={{ start: date, end: date }}
            isClearable
          />
        );
        const trigger = screen.getByTitle(/Select date/);
        expect(trigger).toHaveTextContent('Jan 1st, 2020');
        userEvent.click(trigger);

        // Check that the draft date on the picker is set.
        expect(screen.getByTestId('devseedui-current-date')).toHaveTextContent(
          'Jan 1st, 2020'
        );

        userEvent.click(screen.getByText(/clear date selection/i));

        // Check that the draft date on the picker is not set.
        // And that the picker is still open.
        expect(screen.getByTestId('devseedui-current-date')).toHaveTextContent(
          'Date'
        );

        // Check that the trigger button did not change.
        expect(trigger).toHaveTextContent('Jan 1st, 2020');

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: null,
          end: null
        });

        clock.restore();
      });

      it('should call change callback on draft date change', () => {
        // Ensure we're opening it on a known date.
        const date = new Date('2020/01/01');
        const clock = sinon.useFakeTimers(date.getTime());

        const onConfirmMock = jest.fn();
        const onDateChangeMock = jest.fn();

        renderComp(
          <DatePicker
            id='date-picker'
            onConfirm={onConfirmMock}
            onDateChange={onDateChangeMock}
          />
        );
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // Select a date through the calendar.
        userEvent.click(screen.getByLabelText(/january 10, 2020/i));

        expect(onDateChangeMock.mock.calls.length).toBe(1);
        expect(onDateChangeMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/10')),
          end: startOfDay(new Date('2020/01/10'))
        });

        // Select another date through the calendar.
        userEvent.click(screen.getByLabelText(/january 11, 2020/i));

        expect(onDateChangeMock.mock.calls.length).toBe(2);
        expect(onDateChangeMock.mock.calls[1][0]).toEqual({
          start: startOfDay(new Date('2020/01/11')),
          end: startOfDay(new Date('2020/01/11'))
        });

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/11')),
          end: startOfDay(new Date('2020/01/11'))
        });

        clock.restore();
      });

      it('should render value prop in trigger and picker', () => {
        const { rerender } = renderComp(<DatePicker id='date-picker' />);
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        expect(trigger).toHaveTextContent('Date');
        userEvent.click(trigger);

        // Check that the draft date on the picker is not set.
        const draftDate = screen.getByTestId('devseedui-current-date');
        expect(draftDate).toHaveTextContent('Date');

        rerender(
          <DatePicker id='date-picker' value={new Date('2020/01/01')} />
        );
        // Button should have text Jan 1st, 2020.
        expect(trigger).toHaveTextContent('Jan 1st, 2020');
        expect(draftDate).toHaveTextContent('Jan 1st, 2020');

        // Even if the picker is not range we can pass a range and only start
        // should be used.
        rerender(
          <DatePicker
            id='date-picker'
            value={{
              start: new Date('2020/01/02'),
              end: new Date('2020/01/03')
            }}
          />
        );
        // Button should have text Jan 1st, 2020.
        expect(trigger).toHaveTextContent('Jan 2nd, 2020');
        expect(draftDate).toHaveTextContent('Jan 2nd, 2020');
      });

      it('should render calendar on selected date', () => {
        const result = renderComp(
          <DatePicker id='date-picker' value={new Date('2019/12/01')} />
        );
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        expect(screen.getByText(/december 2019/i)).toBeVisible();

        expect(
          result.baseElement.querySelector('.react-calendar__tile--hasActive')
        ).toHaveTextContent('1');
      });

      it('should render calendar on date set through direct input', () => {
        const result = renderComp(
          <DatePicker id='date-picker' value={new Date('2019/12/01')} />
        );
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        userEvent.clear(directInput);
        userEvent.type(directInput, '2020/01/05{enter}');

        // Change tab.
        const calendarTabBtn = screen.getByTitle(/select calendar tab/i);
        userEvent.click(calendarTabBtn);

        expect(screen.getByText(/january 2020/i)).toBeVisible();

        expect(
          result.baseElement.querySelector('.react-calendar__tile--hasActive')
        ).toHaveTextContent('5');
      });

      it('should render calendar on min when selected date is before min', () => {
        renderComp(
          <DatePicker
            id='date-picker'
            value={new Date('2019/12/01')}
            min={new Date('2020/01/01')}
            max={new Date('2020/03/31')}
          />
        );
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // When date below min, the min should be selected.
        expect(screen.getByText(/january 2020/i)).toBeVisible();
      });

      it('should render calendar on max when selected date is after max', () => {
        renderComp(
          <DatePicker
            id='date-picker'
            value={new Date('2020/12/01')}
            min={new Date('2020/01/01')}
            max={new Date('2020/03/31')}
          />
        );
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // When date above max, the max should be selected.
        expect(screen.getByText(/march 2020/i)).toBeVisible();
      });

      it('should set draft date when typing a valid one', async () => {
        renderComp(<DatePicker id='date-picker' />);
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        userEvent.type(directInput, 'invalid{space}date');
        // Blur should trigger validation.
        directInput.blur();
        expect(directInput).toHaveValue('invalid date');

        // Check that the draft date on the picker not is set.
        expect(screen.getByTestId('devseedui-current-date')).toHaveTextContent(
          'Date'
        );

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        // Enter should also trigger validation.
        userEvent.type(directInput, '2020/01/10{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInput).toHaveValue('Jan 10th, 2020');

        // Check that the draft date on the picker is set.
        expect(screen.getByTestId('devseedui-current-date')).toHaveTextContent(
          'Jan 10th, 2020'
        );
      });

      it('should respect min/max dates on direct input', async () => {
        renderComp(
          <DatePicker
            id='date-picker'
            min={new Date('2020/01/01')}
            max={new Date('2020/01/31')}
          />
        );
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        const currentDate = screen.getByTestId('devseedui-current-date');

        // Date before min.
        userEvent.type(directInput, '2019/12/31{enter}');
        // Check that the draft date on the picker not is set.
        expect(currentDate).toHaveTextContent('Date');

        // Check error message existence.
        screen.getByText(/date must be after or on: jan 1st, 2020/i);

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        // Date after max
        userEvent.type(directInput, '2020/02/10{enter}');
        // Check that the draft date on the picker not is set.
        expect(currentDate).toHaveTextContent('Date');

        // Check error message existence.
        screen.getByText(/date must be before or on: jan 31st, 2020/i);

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        // Valid date
        userEvent.type(directInput, '2020/01/10{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInput).toHaveValue('Jan 10th, 2020');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('Jan 10th, 2020');
      });

      it('should respect year view on direct input', async () => {
        const onConfirmMock = jest.fn();

        renderComp(
          <DatePicker id='date-picker' view='year' onConfirm={onConfirmMock} />
        );
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        const currentDate = screen.getByTestId('devseedui-current-date');

        userEvent.type(directInput, 'invalid{space}date{enter}');
        expect(directInput).toHaveValue('invalid date');
        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        userEvent.type(directInput, '2020/01/10{enter}');
        expect(directInput).toHaveValue('Jan 2020');
        expect(currentDate).toHaveTextContent('Jan 2020');
        // Since the dates are valid we have to manually clear them.
        userEvent.clear(directInput);

        // Inputting a different day shouldn't change the date.
        userEvent.type(directInput, '2020/01/03{enter}');
        expect(directInput).toHaveValue('Jan 2020');
        expect(currentDate).toHaveTextContent('Jan 2020');
        // Since the dates are valid we have to manually clear them.
        userEvent.clear(directInput);

        // Change month.
        userEvent.type(directInput, '2020/02/10{enter}');
        expect(directInput).toHaveValue('Feb 2020');
        expect(currentDate).toHaveTextContent('Feb 2020');

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/02/01')),
          end: startOfDay(new Date('2020/02/01'))
        });
      });

      it('should respect decade view on direct input', async () => {
        const onConfirmMock = jest.fn();

        renderComp(
          <DatePicker
            id='date-picker'
            view='decade'
            onConfirm={onConfirmMock}
          />
        );
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        const currentDate = screen.getByTestId('devseedui-current-date');

        userEvent.type(directInput, 'invalid{space}date{enter}');
        expect(directInput).toHaveValue('invalid date');
        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        userEvent.type(directInput, '2020/01/10{enter}');
        expect(directInput).toHaveValue('2020');
        expect(currentDate).toHaveTextContent('2020');
        // Since the dates are valid we have to manually clear them.
        userEvent.clear(directInput);

        // Inputting a different day shouldn't change the date.
        userEvent.type(directInput, '2020/12/03{enter}');
        expect(directInput).toHaveValue('2020');
        expect(currentDate).toHaveTextContent('2020');
        // Since the dates are valid we have to manually clear them.
        userEvent.clear(directInput);

        // Change year.
        userEvent.type(directInput, '2021/02/10{enter}');
        expect(directInput).toHaveValue('2021');
        expect(currentDate).toHaveTextContent('2021');

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2021/01/01')),
          end: startOfDay(new Date('2021/01/01'))
        });
      });

      it('should respect restricted dates (disabled) on direct input', async () => {
        renderComp(
          <DatePicker
            id='date-picker'
            view='month'
            datesToRestrict={[new Date('2022/05/20'), new Date('2026/01/01')]}
            restrictMode='disable'
          />
        );
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        const currentDate = screen.getByTestId('devseedui-current-date');

        // Enter restricted date.
        userEvent.type(directInput, '2022/05/20{enter}');
        // Check that the draft date on the picker not is set.
        expect(currentDate).toHaveTextContent('Date');

        // Check error message existence.
        screen.getByText(/The inserted date is not allowed/i);

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        // Valid date
        userEvent.type(directInput, '2022/05/10{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInput).toHaveValue('May 10th, 2022');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('May 10th, 2022');
      });

      it('should respect restricted dates (enabled) on direct input', async () => {
        renderComp(
          <DatePicker
            id='date-picker'
            view='month'
            datesToRestrict={[new Date('2022/05/20'), new Date('2026/01/01')]}
            restrictMode='enable'
          />
        );
        openOnInput();

        // textbox
        const directInput = screen.getByLabelText(/date/i, {
          selector: 'input'
        });

        const currentDate = screen.getByTestId('devseedui-current-date');

        // Enter restricted date.
        userEvent.type(directInput, '2022/05/21{enter}');
        // Check that the draft date on the picker not is set.
        expect(currentDate).toHaveTextContent('Date');

        // Check error message existence.
        screen.getByText(/The inserted date is not allowed/i);

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInput).toHaveValue(''));

        // Valid date
        userEvent.type(directInput, '2022/05/20{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInput).toHaveValue('May 20th, 2022');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('May 20th, 2022');
      });
    });

    describe('range date picker', () => {
      it('should render a draft date and commit on confirm', () => {
        // Ensure we're opening it on a known date.
        const date = new Date('2020/01/01');
        const clock = sinon.useFakeTimers(date.getTime());

        const onConfirmMock = jest.fn();

        renderComp(
          <DatePicker id='date-picker' onConfirm={onConfirmMock} isRange />
        );
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        const currentDate = screen.getByTestId('devseedui-current-date');

        // Check that the draft date on the picker is not set.
        expect(currentDate).toHaveTextContent('From start — end');

        // Select a start range through the calendar.
        userEvent.click(getCalendarButton(/january 10, 2020/i));

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('From start — end');

        // Check that the trigger button did not change.
        expect(trigger).toHaveTextContent('From start — end');

        // Select a end range through the calendar.
        userEvent.click(getCalendarButton(/january 15, 2020/i));

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('Jan 10-15, 2020');

        // Check that the trigger button did not change.
        expect(trigger).toHaveTextContent('From start — end');

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/10')),
          end: endOfDay(new Date('2020/01/15'))
        });

        clock.restore();
      });

      it('should call change callback on draft date change', () => {
        // Ensure we're opening it on a known date.
        const date = new Date('2020/01/01');
        const clock = sinon.useFakeTimers(date.getTime());

        const onConfirmMock = jest.fn();
        const onDateChangeMock = jest.fn();

        renderComp(
          <DatePicker
            id='date-picker'
            onConfirm={onConfirmMock}
            onDateChange={onDateChangeMock}
            isRange
          />
        );
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // Select a start range through the calendar.
        userEvent.click(getCalendarButton(/january 20, 2020/i));

        // Select a end range through the calendar.
        userEvent.click(getCalendarButton(/january 25, 2020/i));

        expect(onDateChangeMock.mock.calls.length).toBe(1);
        expect(onDateChangeMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/20')),
          end: endOfDay(new Date('2020/01/25'))
        });

        // Select a start range through the calendar.
        userEvent.click(getCalendarButton(/january 10, 2020/i));

        // Select a end range through the calendar.
        userEvent.click(getCalendarButton(/january 15, 2020/i));

        expect(onDateChangeMock.mock.calls.length).toBe(2);
        expect(onDateChangeMock.mock.calls[1][0]).toEqual({
          start: startOfDay(new Date('2020/01/10')),
          end: endOfDay(new Date('2020/01/15'))
        });

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/10')),
          end: endOfDay(new Date('2020/01/15'))
        });

        clock.restore();
      });

      it('should not commit partial range with calendar', () => {
        // Ensure we're opening it on a known date.
        const date = new Date('2020/01/01');
        const clock = sinon.useFakeTimers(date.getTime());

        const onConfirmMock = jest.fn();

        renderComp(
          <DatePicker id='date-picker' onConfirm={onConfirmMock} isRange />
        );
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // Select a start range through the calendar.
        userEvent.click(getCalendarButton(/january 10, 2020/i));

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: null,
          end: null
        });

        clock.restore();
      });

      it('should render value prop in trigger and picker', () => {
        const { rerender } = renderComp(
          <DatePicker id='date-picker' isRange />
        );
        // Button should have text From start — end.
        const trigger = screen.getByTitle(/Select date/);
        expect(trigger).toHaveTextContent('From start — end');
        userEvent.click(trigger);

        // Check that the draft date on the picker is not set.
        const draftDate = screen.getByTestId('devseedui-current-date');
        expect(draftDate).toHaveTextContent('From start — end');

        rerender(
          <DatePicker
            id='date-picker'
            isRange
            value={{
              start: new Date('2020/01/01'),
              end: new Date('2021/12/31')
            }}
          />
        );
        // Button should have text Jan 1st, 2020.
        expect(trigger).toHaveTextContent('Jan 1st, 2020 — Dec 31st, 2021');
        expect(draftDate).toHaveTextContent('Jan 1st, 2020 — Dec 31st, 2021');
      });

      it('should render calendar on selected date', () => {
        const result = renderComp(
          <DatePicker
            id='date-picker'
            isRange
            value={{
              start: new Date('2020/01/01'),
              end: new Date('2020/12/31')
            }}
          />
        );
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // If both available use end date to open calendar to.
        expect(screen.getByText(/december 2020/i)).toBeVisible();

        expect(
          result.baseElement.querySelector('.react-calendar__tile--hasActive')
        ).toHaveTextContent('31');
      });

      it('should render calendar on selected date no end', () => {
        const result = renderComp(
          <DatePicker
            id='date-picker'
            isRange
            value={{
              start: new Date('2020/01/01'),
              end: null
            }}
          />
        );
        // Button should have text Date.
        const trigger = screen.getByTitle(/Select date/);
        userEvent.click(trigger);

        // If only start available use it to open calendar to.
        expect(screen.getByText(/january 2020/i)).toBeVisible();

        expect(
          result.baseElement.querySelector('.react-calendar__tile--hasActive')
        ).toHaveTextContent('1');
      });

      it('should set draft date when typing a valid one for start and end', async () => {
        renderComp(<DatePicker id='date-picker' isRange />);
        openOnInput();

        const directInputStart = screen.getByLabelText(/start date/i);
        const directInputEnd = screen.getByLabelText(/end date/i);

        const currentDate = screen.getByTestId('devseedui-current-date');

        userEvent.type(directInputStart, 'invalid{space}date');
        // Blur should trigger validation.
        directInputStart.blur();
        expect(directInputStart).toHaveValue('invalid date');

        // Check that the draft date on the picker not is set.
        expect(currentDate).toHaveTextContent('From start — end');

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInputStart).toHaveValue(''));

        // Enter should also trigger validation.
        userEvent.type(directInputStart, '2020/01/10{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInputStart).toHaveValue('Jan 10th, 2020');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('Jan 10th, 2020 — end');

        userEvent.type(directInputEnd, 'invalid{space}date');
        // Blur should trigger validation.
        directInputEnd.blur();
        expect(directInputEnd).toHaveValue('invalid date');

        // Check that the draft date on the picker is the same as before.
        expect(currentDate).toHaveTextContent('Jan 10th, 2020 — end');

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInputEnd).toHaveValue(''));

        // Enter should also trigger validation.
        userEvent.type(directInputEnd, '2020/02/03{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInputEnd).toHaveValue('Feb 3rd, 2020');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('Jan 10th — Feb 3rd, 2020');
      });

      it('should set draft date when typing a valid one for start and end reversed', async () => {
        renderComp(<DatePicker id='date-picker' isRange />);
        openOnInput();

        const directInputStart = screen.getByLabelText(/start date/i);
        const directInputEnd = screen.getByLabelText(/end date/i);

        const currentDate = screen.getByTestId('devseedui-current-date');

        userEvent.type(directInputEnd, 'invalid{space}date');
        // Blur should trigger validation.
        directInputEnd.blur();
        expect(directInputEnd).toHaveValue('invalid date');

        // Check that the draft date on the picker not is set.
        expect(currentDate).toHaveTextContent('From start — end');

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInputEnd).toHaveValue(''));

        // Enter should also trigger validation.
        userEvent.type(directInputEnd, '2020/02/03{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInputEnd).toHaveValue('Feb 3rd, 2020');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('From start — Feb 3rd, 2020');

        userEvent.type(directInputStart, 'invalid{space}date');
        // Blur should trigger validation.
        directInputStart.blur();
        expect(directInputStart).toHaveValue('invalid date');

        // Check that the draft date on the picker is the same as before.
        expect(currentDate).toHaveTextContent('From start — Feb 3rd, 2020');

        // An invalid value will trigger the stressed field animation, and the
        // field gets cleared after that. Wait for it.
        await waitFor(() => expect(directInputStart).toHaveValue(''));

        // Enter should also trigger validation.
        userEvent.type(directInputStart, '2020/01/10{enter}');
        // When valid the field gets converted to the formatted value.
        expect(directInputStart).toHaveValue('Jan 10th, 2020');

        // Check that the draft date on the picker is set.
        expect(currentDate).toHaveTextContent('Jan 10th — Feb 3rd, 2020');
      });

      it('should show error if start is after end', async () => {
        renderComp(<DatePicker id='date-picker' isRange />);
        openOnInput();

        const directInputStart = screen.getByLabelText(/start date/i);
        const directInputEnd = screen.getByLabelText(/end date/i);

        userEvent.type(directInputEnd, '2020/01/01{enter}');
        userEvent.type(directInputStart, '2021/01/10{enter}');

        // Check error message existence.
        expect(
          screen.getByText(/date must be before end date: jan 1st, 2020/i)
        ).toBeVisible();
      });

      it('should show error if end is before start', async () => {
        renderComp(<DatePicker id='date-picker' isRange />);
        openOnInput();

        const directInputStart = screen.getByLabelText(/start date/i);
        const directInputEnd = screen.getByLabelText(/end date/i);

        userEvent.type(directInputStart, '2020/01/01{enter}');
        userEvent.type(directInputEnd, '2019/01/10{enter}');

        // Check error message existence.
        expect(
          screen.getByText(/date must be after start date: jan 1st, 2020/i)
        ).toBeVisible();
      });

      it('should select the end on the day for end date', () => {
        const onConfirmMock = jest.fn();

        renderComp(
          <DatePicker id='date-picker' onConfirm={onConfirmMock} isRange />
        );
        openOnInput();

        const directInputStart = screen.getByLabelText(/start date/i);
        const directInputEnd = screen.getByLabelText(/end date/i);

        userEvent.type(directInputStart, '2020/01/10{enter}');
        userEvent.type(directInputEnd, '2020/01/15{enter}');

        userEvent.click(screen.getByText(/save date selection/i));

        expect(onConfirmMock.mock.calls.length).toBe(1);
        expect(onConfirmMock.mock.calls[0][0]).toEqual({
          start: startOfDay(new Date('2020/01/10')),
          end: endOfDay(new Date('2020/01/15'))
        });
      });

      it('renders SSR compatible <DatePicker />', () => {
        const renderOnServer = () =>
          renderToString(
            <DevseedUiThemeProvider>
              <DatePicker id='date-picker' />
            </DevseedUiThemeProvider>
          );
        expect(renderOnServer).not.toThrow();
      });
    });
  });
});
