import {
  endOfMonth,
  format,
  getDayOfYear,
  isSameMonth,
  isSameYear,
  parse
} from 'date-fns';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

const DATE_FORMAT_YEAR = 'yyyy';
const DATE_FORMAT_MONTH = 'MMM yyyy';
const DATE_FORMAT_FULL = 'MMM do, yyyy';

/**
 * Formats a date according to view
 *
 * @param {Date} date Date to format
 * @param {Object} opts Options
 * @param {string} opts.view Date view. One of (decade|year|month)
 */
export const formatDate = (date, { view }) => {
  if (!date) return '';

  switch (view) {
    case 'decade':
      return format(date, DATE_FORMAT_YEAR);
    case 'year':
      return format(date, DATE_FORMAT_MONTH);
    default:
      return format(date, DATE_FORMAT_FULL);
  }
};

/**
 * Format the label in a pretty way as to not repeat values if the month or
 * year are the same.
 * Examples:
 * Jan 1st, 2020 - Dec 31st, 2021
 * Jan 1st - Dec 31st, 2020
 * Dec 01-31, 2020
 * Dec 31st, 2020
 *
 * @param {object} range Date range to format
 * @param {Object} opts Options
 * @param {string} opts.view Date view. One of (decade|year|month)
 */
export const formatRangeLabel = (range, { view } = {}) => {
  const { start, end } = range;

  // Format the label in a pretty way as to not repeat values if the month or
  // year are the same.
  // Examples:
  // Jan 1st, 2020 - Dec 31st, 2021
  // Jan 1st - Dec 31st, 2020
  // Dec 01-31, 2020
  // Dec 31st, 2020

  // If we're missing the start or the end just use the date format since we're
  // only technically formatting one date.
  const dateFormat =
    view === 'decade'
      ? DATE_FORMAT_YEAR
      : view === 'year'
      ? DATE_FORMAT_MONTH
      : DATE_FORMAT_FULL;

  if (start) {
    const startStr = format(start, dateFormat);

    if (!end) {
      return `${startStr} — end`;
    }

    const endStr = format(end, dateFormat);

    if (startStr === endStr) {
      return startStr;
    }

    // Things get trickier when we have to compare dates. Here the range plays a
    // role.
    if (isSameMonth(start, end) && isSameYear(start, end)) {
      // decade view does not matter because being the same year it gets
      // captured above and is the same for same month.
      return `${format(start, 'MMM dd')}-${format(end, 'dd, yyyy')}`;
    } else if (isSameYear(start, end)) {
      // decade view does not matter because being the same year it gets
      // captured above.
      if (view === 'year') {
        return `${format(start, 'MMM')} — ${endStr}`;
      }

      return `${format(start, 'MMM do')} — ${endStr}`;
    } else {
      return `${startStr} — ${endStr}`;
    }
  } else if (end) {
    return `From start — ${format(end, dateFormat)}`;
  }

  return 'From start — end';
};

/**
 * Formats a date or range according to view
 *
 * @param {Date|Object} date Date o range to format
 * @param {Object} opts Options
 * @param {string} opts.view Date view. One of (decade|year|month)
 * @param {bool} opts.isRange Whether the date is a range
 */
export const formatDateLabel = (value, { view, isRange }) => {
  return isRange
    ? formatRangeLabel(value, { view })
    : formatDate(value.start, { view }) || 'Date';
};

/**
 * Tries to parse the input date string and returns a date according to the
 * desired view.
 *
 * Some input examples:
 * 10 january 2020
 * january 10 2020
 * jan 10 2020
 * 2020/10/10
 *
 * @param {string} str The input date string.
 * @param {Object} opts Options
 * @param {string} opts.view Date view. One of (decade|year|month)
 */
export const parseDateStr = (str, { view } = {}) => {
  const dateStr = str.trim().toLowerCase();
  // Date from which to get base values for date-fns
  // Construct a date taking the user's tz into account.
  const baseDate = new Date('1970/01/01');

  let date;

  if (view === 'decade') {
    // Looking for just the year.
    // Try parsing with other view as it may work.
    date = parseDateStr(dateStr, { view: 'year' });
    if (date) {
      date.setMonth(0);
    } else {
      date = parse(dateStr, 'yyyy', baseDate);
    }
  } else if (view === 'year') {
    // Try parsing with other views as it may work.
    date = parseDateStr(dateStr, { view: 'month' });

    if (date) {
      date.setDate(1);
    } else {
      // Looking for the year and month.
      // Supported formats:
      // jan 2020
      // 01/2020
      // 01-2020
      // 2020-01
      // These can be supported by using Date.parse and prepending of appending
      // the day depending on whether we start or end with the year.
      const cleanString = dateStr.match(/[0-9]{4}/)
        ? // Starts with year. Add at the end.
          `${dateStr.replace(/-/g, ' ')} 01`
        : // Add at the beginning on other cases.
          `01 ${dateStr.replace(/-/g, ' ')}`;
      const time = Date.parse(cleanString);
      date = new Date(time);
    }
  } else if (!view || view === 'month') {
    // The date should always be in the user's TZ but the input string affects
    // how the date is constructed.
    // An input string of only year or with `-` (2020-01 | 2020-1-1) will be
    // considered to be in ISO format, meaning that the user date will be this
    // date +- the TZ offset. For example:
    // 2020-01-01
    //   Tue Dec 31 2019 19:00:00 GMT-0500 (Eastern Standard Time)
    //   Wed Jan 01 2020 01:00:00 GMT+0100 (Central European Time)
    //
    // whereas 2020/01/01
    //   Wed Jan 01 2020 00:00:00 GMT-0500 (Eastern Standard Time)
    //   Wed Jan 01 2020 00:00:00 GMT+0100 (Central European Time)
    // and if converted to ISO
    //   2020-01-01T05:00:00.000Z
    //   2020-01-01T01:00:00.000Z
    //
    // The code below ensures that all dates behave the same.
    //
    const isoYearOrMonth = dateStr.match(/^([0-9]{4})(?:-([0-9]{1,2}))?$/);
    const isoMatch = dateStr.match(/^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})/);

    let cleanString;

    if (isoYearOrMonth) {
      // If the date is in partial ISO format (YYYY) (YYYY-MM) then we need to
      // construct it to take the user TZ into account.
      const [, y, m = '01'] = isoYearOrMonth;
      cleanString = `${y}/${m}/01`;
    } else if (isoMatch) {
      // If the date is in ISO format (YYYY-MM-DD) then we need to construct it
      // to take the user TZ into account.
      const [, y, m, d] = isoMatch;
      cleanString = `${y}/${m}/${d}`;
    } else {
      // For the full date view Date does a good job, except with the ordinal
      // numbers. Remove those from the date before parsing.
      cleanString = dateStr.replace(/([0-9])(st|nd|rd|th)/g, '$1');
    }

    date = new Date(cleanString);
  }

  return isNaN(date.getTime()) ? null : date;
};

/**
 * Compares two dates.
 * Returns 0 if they're the same, 1 if date A is greater, or -1 otherwise.
 *
 * @param {Date} a First date for comparison
 * @param {Date} b Second date for comparison
 * @param {Object} opts Options
 * @param {string} opts.view Date view. One of (decade|year|month)
 */
export const compareDates = (a, b, { view }) => {
  // Comparison can be done by they string representation, based on view.
  const formatYear = 'yyyy';
  const formatMonth = 'yyyy/MM';
  const formatDay = 'yyyy/MM/dd';
  let aStr;
  let bStr;

  switch (view) {
    case 'decade':
      aStr = format(a, formatYear);
      bStr = format(b, formatYear);
      break;
    case 'year':
      aStr = format(a, formatMonth);
      bStr = format(b, formatMonth);
      break;
    default:
      aStr = format(a, formatDay);
      bStr = format(b, formatDay);
      break;
  }

  if (aStr === bStr) return 0;
  if (aStr < bStr) return -1;
  return 1;
};

/**
 * Validates and prepares user provided dates.
 *
 * @param {Date|object} value Input date to validate. Can be a single date or an
 * object with a start and end.
 * @param {Object} opts Options
 * @param {string} opts.view Date view. One of (decade|year|month)
 * @param {bool} opts.isRange Whether the input is be a range.
 */
export const prepareInputDates = (value, { isRange, view } = {}) => {
  if (!value) {
    return {
      start: null,
      end: null
    };
  }

  // Let's do some input validation.
  if (!isRange) {
    // Value can be a date directly, if not check for value.start
    const d =
      value instanceof Date
        ? value
        : value.start instanceof Date
        ? value.start
        : null;
    return {
      start: d,
      end: d
    };
  } else {
    const dStart =
      value.start && value.start instanceof Date ? value.start : null;
    const dEnd = value.end && value.end instanceof Date ? value.end : null;

    // If we have both dates, ensure they're in order.
    if (dStart && dEnd) {
      return compareDates(dStart, dEnd, { view }) === -1
        ? {
            start: dStart,
            end: dEnd
          }
        : {
            start: dEnd,
            end: dStart
          };
    } else {
      return {
        start: dStart,
        end: dEnd
      };
    }
  }
};

/**
 * React hook to set state. Same behavior as useState but won't set the state if
 * the component is unmounted.
 * @param {*} initialValue Initial state value.
 */
export const useSafeState = (initialValue) => {
  const isMountedRef = useRef(true);
  const [currentValue, setCurrentValue] = useState(initialValue);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, [isMountedRef]);

  const setSafeState = useCallback((value) => {
    if (isMountedRef && isMountedRef.current) {
      setCurrentValue(value);
    }
  }, []);

  return [currentValue, setSafeState];
};

/**
 * Computes the years, months and days that need to be disabled from a list of
 * dates.
 *
 * @param {Date[]} dateList Array of dates
 * @param {object} options
 * @param {string} options.view One of "month", "year", "decade"
 * @returns { years: Date[] months: Date[], days: Date[] }
 */
export const computeDisabledDates = (dateList, { view }) => {
  // Group each date by its year and year/month
  // We then count the size of the set. If it matches the size of the year or
  // month we know the full thing is disabled.
  // 2022     --> Set()
  // 2022/01  --> Set()
  const dateSet = dateList.reduce((acc, date) => {
    // How the dates are grouped depends on the view:
    const groupFormat = {
      month: 'yyyy/MM/dd',
      year: 'yyyy/MM',
      decade: 'yyyy'
    }[view];

    // Use a formatted date so the Set() can compare them uniquely.
    const formattedDate = format(date, groupFormat);

    // Dates that share a month.
    const m = format(date, 'yyyy/MM');
    if (!acc[m]) acc[m] = new Set();
    acc[m].add(formattedDate);

    // Dates that share a year.
    const y = format(date, 'yyyy');
    if (!acc[y]) acc[y] = new Set();
    acc[y].add(formattedDate);

    return acc;
  }, {});

  const toDisable = Object.entries(dateSet).reduce(
    (acc, [key, theSet]) => {
      // Dealing with a year.
      // YYYY -> 4 chars
      if (key.length === 4) {
        const expectedSize = {
          month: getDayOfYear(new Date(`${key}/12/31`)),
          year: 12,
          decade: 1
        }[view];

        // If we all the expected items the the year should be disabled.
        // If we're selecting days (month view) then for a year to be disabled
        // we need 365 or 366 entries.
        // If we're selecting months (year view) then for a year to be disabled
        // we need 12 entries.
        // and so on
        if (theSet.size === expectedSize) {
          acc.years.push(new Date(`${key}/01/01`));
          return acc;
        }
      }

      // Dealing with a month.
      // YYYY/MM -> 7 chars
      if (key.length === 7) {
        const expectedSize = {
          month: endOfMonth(new Date(`${key}/01`)).getDate(),
          year: 1,
          decade: 1
        }[view];

        // If we have items for the whole month it should be disabled.
        if (theSet.size === expectedSize) {
          acc.months.push(new Date(`${key}/01`));
          return acc;
        }
      }

      return acc;
    },
    { years: [], months: [] }
  );

  switch (view) {
    case 'month':
      return {
        ...toDisable,
        days: dateList
      };
    case 'year':
      return {
        ...toDisable,
        days: []
      };
    case 'decade':
      return {
        ...toDisable,
        months: [],
        days: []
      };
  }
};

/**
 * Returns a callback function to check if a date is not allowed.
 *
 * @param {Date[]} datesToRestrict Array of dates
 * @param {string} restrictMode What to do with the dates.
 *                 One of "enable", "disable"
 * @param {object} options
 * @param {string} options.view One of "month", "year", "decade"
 *
 * @returns hook
 */
export const useDateNotAllowed = (datesToRestrict, restrictMode, { view }) => {
  const restrictDateByUnit = useMemo(() => {
    if (!datesToRestrict?.length) return null;

    if (!['month', 'year', 'decade'].includes(view)) {
      throw new Error(`Invalid view value: ${view}`);
    }

    if (restrictMode === 'enable') {
      // When enabling the dates one item found is enough to enable the whole
      // thing (ex: a single day will enable the whole month), therefore all the
      // values can be the same. This structure is only used to ensure
      // consistency.
      return {
        days: datesToRestrict,
        months: datesToRestrict,
        years: datesToRestrict
      };
    }

    if (restrictMode === 'disable') {
      return computeDisabledDates(datesToRestrict, { view });
    }

    throw new Error(`Invalid restrictMode value: ${restrictMode}`);
  }, [restrictMode, datesToRestrict, view]);

  return useCallback(
    ({ date, view: currentView }) => {
      // Don't do anything if there are no dates.
      if (!restrictDateByUnit) return false;

      const isEnabling = restrictMode === 'enable';

      // Map the calendar view to our dates structure. The calendar view refers
      // to the parent instead of the unit (if we're views the days, the
      // calendar calls it month view.)
      const v = {
        month: 'days',
        year: 'months',
        decade: 'years'
      }[currentView];

      const dateFound = restrictDateByUnit[v].some(
        (d) => compareDates(date, d, { view: currentView }) === 0
      );
      return isEnabling ? !dateFound : dateFound;
    },
    [restrictDateByUnit, restrictMode]
  );
};
